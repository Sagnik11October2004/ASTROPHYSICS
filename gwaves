# file_path: binary_system_gw_simulation_advanced.py

import numpy as np
import matplotlib.pyplot as plt
import lal
import lalsimulation as lalsim

# Constants
G = 6.67430e-11  # Gravitational constant, m^3 kg^-1 s^-2
c = 2.998e8  # Speed of light, m/s

class BinarySystem:
    def __init__(self, m1, m2, initial_separation):
        self.m1 = m1
        self.m2 = m2
        self.r = initial_separation
        self.mu = m1 * m2 / (m1 + m2)
        self.M = m1 + m2

        # Initialize LALSuite objects
        self.m1_SI = m1 * lal.MSUN_SI
        self.m2_SI = m2 * lal.MSUN_SI
        self.distance = 1e6 * lal.PC_SI  # Distance to the binary system in parsecs (converted to meters)
        
        # Get initial frequency from the separation
        self.initial_frequency = self._initial_orbital_frequency()

    def _initial_orbital_frequency(self):
        return np.sqrt(G * self.M / self.r**3) / (2 * np.pi)

    def gravitational_wave_frequency(self):
        return self.initial_frequency

    def gravitational_wave_amplitude(self, time):
        f_gw = self.gravitational_wave_frequency()
        hp, hc = lalsim.SimInspiralChooseTDWaveform(
            self.m1_SI, self.m2_SI,
            0, 0, 0, 0, 0, 0,
            self.distance, 0, 0, 0,
            time, 1.0/lalsim.SimInspiralTransformPrecessingNewInitialConditions(f_gw, 0),
            None, lalsim.GetApproximantFromString("IMRPhenomPv2")
        )
        return hp.data.data, hc.data.data

    def update(self, time_step):
        # Using LALSuite for accurate orbital evolution and gravitational waveforms
        # Here we will assume the evolution step is handled by the waveform generator

        f_gw = self.gravitational_wave_frequency()
        h_plus, h_cross = self.gravitational_wave_amplitude(time_step)

        return f_gw, h_plus, h_cross

def simulate_binary_system(m1, m2, initial_separation, time_step, num_steps):
    system = BinarySystem(m1, m2, initial_separation)
    
    frequencies = []
    amplitudes_plus = []
    amplitudes_cross = []
    separations = []
    times = np.linspace(0, time_step * num_steps, num_steps)
    
    for i in range(num_steps):
        f_gw, h_plus, h_cross = system.update(times[i])
        frequencies.append(f_gw)
        amplitudes_plus.append(h_plus)
        amplitudes_cross.append(h_cross)
        separations.append(system.r)
    
    return times, frequencies, amplitudes_plus, amplitudes_cross, separations

def plot_results(times, frequencies, amplitudes_plus, amplitudes_cross, separations):
    fig, axs = plt.subplots(5, 1, figsize=(10, 20))

    axs[0].plot(times, frequencies)
    axs[0].set_xlabel('Time (s)')
    axs[0].set_ylabel('Gravitational Wave Frequency (Hz)')
    axs[0].set_title('Gravitational Wave Frequency over Time')

    axs[1].plot(times, amplitudes_plus)
    axs[1].set_xlabel('Time (s)')
    axs[1].set_ylabel('Gravitational Wave Amplitude Plus')
    axs[1].set_title('Gravitational Wave Amplitude Plus over Time')

    axs[2].plot(times, amplitudes_cross)
    axs[2].set_xlabel('Time (s)')
    axs[2].set_ylabel('Gravitational Wave Amplitude Cross')
    axs[2].set_title('Gravitational Wave Amplitude Cross over Time')

    axs[3].plot(times, separations)
    axs[3].set_xlabel('Time (s)')
    axs[3].set_ylabel('Separation (m)')
    axs[3].set_title('Orbital Separation over Time')

    axs[4].plot(times, [np.sqrt(hp**2 + hc**2) for hp, hc in zip(amplitudes_plus, amplitudes_cross)])
    axs[4].set_xlabel('Time (s)')
    axs[4].set_ylabel('Gravitational Wave Amplitude')
    axs[4].set_title('Combined Gravitational Wave Amplitude over Time')

    plt.tight_layout()
    plt.show()

# Example usage
if __name__ == "__main__":
    m1 = 1.4  # Mass of the first star (e.g., neutron star) in solar masses
    m2 = 1.4  # Mass of the second star (e.g., neutron star) in solar masses
    initial_separation = 1e7  # Initial separation in meters

    time_step = 1  # Time step in seconds
    num_steps = 10000  # Number of steps in the simulation

    times, frequencies, amplitudes_plus, amplitudes_cross, separations = simulate_binary_system(m1, m2, initial_separation, time_step, num_steps)
    plot_results(times, frequencies, amplitudes_plus, amplitudes_cross, separations)
