using StaticArrays
using LinearAlgebra
using Plots

# Constants
const G = 6.67430e-11  # Gravitational constant
const M_sun = 1.989e30  # Solar mass in kg
const pc = 3.086e16  # Parsec in meters

# Simulation parameters
const N = 1000  # Initial number of particles
const L = 1.0 * pc  # Box size
const m = 100 * M_sun / N  # Initial particle mass
const h = 0.01 * pc  # Initial smoothing length
const dt = 20 * 365 * 24 * 3600.0  # Time step (1000 years)

# Particle structure
mutable struct Particle
    pos::SVector{3, Float64}
    vel::SVector{3, Float64}
    mass::Float64
end

# Initialize particles
function initialize_particles()
    return [Particle(SVector{3}(rand(3) .* L), SVector{3}(randn(3) .* 1000.0), m) for _ in 1:N]
end

# Periodic boundary conditions
function apply_periodic_bc!(p::Particle)
    p.pos = mod.(p.pos, L)
end

# Tree node structure for the octree
mutable struct TreeNode
    center::SVector{3, Float64}
    size::Float64
    particles::Vector{Particle}
    children::Vector{TreeNode}
    total_mass::Float64
    com::SVector{3, Float64}
end

# Build the octree
function build_tree(particles, center, size)
    node = TreeNode(center, size, particles, [], 0.0, zero(SVector{3, Float64}))
    
    if length(particles) <= 1
        node.total_mass = isempty(particles) ? 0.0 : particles[1].mass
        node.com = isempty(particles) ? zero(SVector{3, Float64}) : particles[1].pos
        return node
    end
    
    node.total_mass = sum(p.mass for p in particles)
    node.com = sum(p.pos * p.mass for p in particles) / node.total_mass
    
    if length(particles) <= 8
        return node
    end
    
    # Create child nodes
    for octant in 1:8
        new_center = center + SVector{3}([(octant & 1 > 0 ? 0.25 : -0.25) * size,
                                          (octant & 2 > 0 ? 0.25 : -0.25) * size,
                                          (octant & 4 > 0 ? 0.25 : -0.25) * size])
        child_particles = filter(p -> all(abs.(p.pos .- new_center) .<= 0.25 * size), particles)
        if !isempty(child_particles)
            push!(node.children, build_tree(child_particles, new_center, 0.5 * size))
        end
    end
    
    return node
end

# Calculate gravitational force using the tree
function calculate_gravity(particle::Particle, node::TreeNode, theta::Float64)
    r = norm(particle.pos - node.com)
    if r == 0
        return zero(SVector{3, Float64})
    end
    
    if isempty(node.children) || node.size / r < theta
        direction = normalize(node.com - particle.pos)
        return G * particle.mass * node.total_mass / r^2 * direction
    else
        return sum(calculate_gravity(particle, child, theta) for child in node.children)
    end
end

# Calculate pressure force (simple model)
function calculate_pressure(particles::Vector{Particle}, i::Int, h::Float64)
    force = zero(SVector{3, Float64})
    for j in 1:length(particles)
        if i != j
            r = norm(particles[i].pos - particles[j].pos)
            if r < h
                direction = normalize(particles[j].pos - particles[i].pos)
                force += direction * (1 - r/h)^2
            end
        end
    end
    return force * 1e-5  # Scaling factor for pressure force
end

# Update particle positions and velocities
function update_particles!(particles::Vector{Particle}, tree::TreeNode, dt::Float64, h::Float64)
    for (i, p) in enumerate(particles)
        grav_force = calculate_gravity(p, tree, 0.5)
        pressure_force = calculate_pressure(particles, i, h)
        total_force = grav_force + pressure_force
        
        p.vel += total_force / p.mass * dt
        p.pos += p.vel * dt
        apply_periodic_bc!(p)
    end
end

# Clump particles
function clump_particles!(particles::Vector{Particle}, h::Float64)
    i = 1
    while i < length(particles)
        j = i + 1
        while j <= length(particles)
            if norm(particles[i].pos - particles[j].pos) < h
                particles[i].mass += particles[j].mass
                particles[i].vel = (particles[i].vel * particles[i].mass + particles[j].vel * particles[j].mass) / (particles[i].mass + particles[j].mass)
                deleteat!(particles, j)
            else
                j += 1
            end
        end
        i += 1
    end
end

# Main simulation loop
function run_simulation(num_steps::Int)
    particles = initialize_particles()
    results = []
    
    for step in 1:num_steps
        tree = build_tree(particles, SVector{3}(L/2, L/2, L/2), L)
        update_particles!(particles, tree, dt, h)
        clump_particles!(particles, h)
        
        if step % 10 == 0
            push!(results, (step * dt, length(particles), copy(particles)))
            plot_results(results)
        end
    end
    
    return results
end

# Plot results
function plot_results(results)
    for (time, num_particles, particles) in results
        positions = reduce(hcat, [p.pos for p in particles])
        masses = [p.mass for p in particles]
        
        plt = scatter(positions[1, :], positions[2, :], positions[3, :],
                      markersize = masses ./ minimum(masses) .* 2,
                      title = "Time: $(round(time / (365 * 24 * 3600))) years, Particles: $num_particles",
                      xlabel = "X (m)", ylabel = "Y (m)", zlabel = "Z (m)",
                      legend = false, size = (800, 600))
        display(plt)
        sleep(0.1)
    end
end

# Run the simulation and plot results
results = run_simulation(5000)
